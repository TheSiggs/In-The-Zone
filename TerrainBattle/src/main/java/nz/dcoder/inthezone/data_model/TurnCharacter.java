package nz.dcoder.inthezone.data_model;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import nz.dcoder.ai.astar.AStarSearch;
import nz.dcoder.ai.astar.Node;
import nz.dcoder.inthezone.data_model.pure.AbilityInfo;
import nz.dcoder.inthezone.data_model.pure.AbilityName;
import nz.dcoder.inthezone.data_model.pure.CharacterInfo;
import nz.dcoder.inthezone.data_model.pure.CharacterName;
import nz.dcoder.inthezone.data_model.pure.EffectName;
import nz.dcoder.inthezone.data_model.pure.LineOfSight;
import nz.dcoder.inthezone.data_model.pure.Points;
import nz.dcoder.inthezone.data_model.pure.Position;

/**
 * Combines a character with turns specific information about the character
 * */
public class TurnCharacter {
	public int mp;
	public int ap;
	public int maxMP;
	public int maxAP;
	private final Character character;
	private final int turnNumber;
	private final Battle battle;

	public TurnCharacter(
		Character character,
		int turnNumber,
		Battle battle
	) {
		this.character = character;
		this.turnNumber = turnNumber;
		this.battle = battle;
		this.maxMP = character.getBaseStats().baseMP;
		this.maxAP = character.getBaseStats().baseAP;
		mp = maxMP;
		ap = maxAP;
	}

	/**
	 * Get all the positions this character could move to, which depends on the
	 * current MP and configuration of the board.
	 * */
	public Collection<Position> getMoveRange() {
		return LineOfSight.getDiamond(character.position, mp).stream()
			.filter(p -> getMove(null, p) != null)
			.collect(Collectors.toList());
	}

	/**
	 * Get a path on behalf of the presentation layer.  This method is designed
	 * to permit waypoints.  The soFar parameter contains the path up until now.
	 *
	 * Note: This method does not check that the destination is unoccupied.  That
	 * check is to be done by the GUI and repeated by "doMotion".  This method
	 * does, however, check that the destination is not an obstacle.
	 *
	 * @param soFar The path taken so far.  Set to null if this is the first
	 * waypoint
	 * @param destination The destination.  This may be a waypoint in which case a
	 * subsequent call to getMove gets the rest of the path
	 *
	 * @return null if there is no path for this character to the destination, or
	 * if this character does not have enough MP to reach the destination.
	 * Returns a new list every time, containing the complete path including the
	 * start position and the contents of the "soFar" parameter.
	 * */
	public List<Position> getMove(List<Position> soFar, Position destination) {
		int width = battle.terrain.getWidth();
		int height = battle.terrain.getHeight();

		// ensure that the destination is valid
		if (
			destination.x >= width || destination.x < 0 ||
			destination.y >= height || destination.y < 0 ||
			battle.getOccupiedPositions().contains(destination)
		) {
			return null;
		}

		if (soFar == null) {
			soFar = new ArrayList<Position>();
		}

		Position startPos;
		if (soFar.size() > 0) {
			int last = soFar.size() - 1;
			startPos = soFar.remove(last);
		} else {
			startPos = character.position;
		}

		if (startPos.equals(destination)) return soFar;

		// start of pathfinding code
		Set<Position> obstacles = new HashSet<Position>(
			battle.getObstacles(battle.turn.isPlayerTurn));

		Node<Position> start = new AStarPositionNode(null,
			obstacles, width, height, startPos, destination);

		AStarSearch search = new AStarSearch(start);
		List<Node<Position>> npath = search.search();

		if (npath.size() + soFar.size() - 1 > mp) {
			return null;
		} else {
			return Stream.concat(
				soFar.stream(),
				npath.stream().map(n -> n.getPosition())
			).collect(Collectors.toList());
		}
	}

	/**
	 * Cause the character to move along the specified path.
	 *
	 * May cause zero or more onMove events.  May also cause zero of more
	 * onAbility events if the character triggers certain objects such as mines
	 *
	 * @param path The path (generated by getMove) along which the character is
	 * to walk
	 * */
	public void doMotion(List<Position> path) {
		battle.checkTurn(turnNumber);

		if (path == null) {
			throw new RuntimeException("Path is null");
		} else if (path.size() - 1 > mp || path.size() < 2) {
			throw new RuntimeException("Invalid path " + path.toString());
		}

		List<Position> pathSoFar = new ArrayList<Position>();
		while (path.size() > 0) {
			Position p = path.remove(0);
			pathSoFar.add(p);

			Collection<BattleObject> os = battle.getTriggeredObjects(p);
			if (os.size() > 0) {
				path.add(0, p);
				doMotion0(pathSoFar);

				for (BattleObject o : os) {
					// trigger object abilities
					Ability ability = o.ability.ability;
					Position op0 = o.position;

					Collection<Position> targets = ability.getTargets(
						ability.getAffectedArea(p, p, battle), battle);

					ability.applyEffect(o.ability, p, battle);

					battle.controller.callOnAbility(
						op0, character.position, targets, ability.info);
				}

				pathSoFar = new ArrayList<Position>();
			}
		}

		if (pathSoFar.size() > 0) {
			doMotion0(pathSoFar);
		}
	}

	/**
	 * Assumes that the first element of path is the current position of the
	 * character.
	 * */
	private void doMotion0(List<Position> path) {
		mp -= path.size() - 1;
		Position p0 = character.position;
		character.position = path.get(path.size() - 1);

		boolean enterLeaveManaZone =
			battle.terrain.isManaZone(p0) !=
			battle.terrain.isManaZone(character.position);

		battle.controller.callOnMove(p0, path, enterLeaveManaZone);
	}

	private Ability getAbility(AbilityName name) {
		return character.getAbilities(isOnManaZone()).stream()
			.filter(a -> a.info.name.equals(name)).findFirst().orElse(null);
	}

	private final EffectName pushEffect = new EffectName("push");

	/**
	 * Get all the positions that could be targeted by an ability.
	 * */
	public Collection<Position> getAbilityRange(AbilityName name) {
		AbilityInfo info = getAbility(name).info;

		return LineOfSight.getDiamond(character.position, info.range).stream()
			.filter(p -> canDoAbility(name, p))
			.collect(Collectors.toList());
	}

	/**
	 * Determine if this character can perform an ability with a given target
	 * */
	public boolean canDoAbility(AbilityName name, Position target) {
		Ability ability = getAbility(name);
		if (ability.info.effect.equals(pushEffect)) {
			// The push effect costs MP
			if (ability == null || ability.info.cost > mp) return false;
		} else {
			// All other effects cost AP
			if (ability == null || ability.info.cost > ap) return false;
		}
		return ability.canApplyEffect(character, target, battle);
	}

	/**
	 * Get the area of effect of an ability
	 * */
	public Collection<Position> getAffectedArea(
		AbilityName name, Position target
	) {
		Ability ability = getAbility(name);
		if (ability == null) {
			return new ArrayList<Position>();
		} else {
			return ability.getAffectedArea(character.position, target, battle);
		}
	}

	/**
	 * Get the targets of an ability.  These are the squares that contain
	 * characters or objects that will be affected by the ability, assuming it is
	 * possible to use the ability
	 * */
	public Collection<Position> getTargets(
		AbilityName name, Position target
	) {
		Ability ability = getAbility(name);
		if (ability == null) {
			return new ArrayList<Position>();
		} else {
			return ability.getTargets(
				ability.getAffectedArea(character.position, target, battle), battle);
		}
	}

	/**
	 * Perform an ability.  This will an onAbility event which carries the
	 * squares on which targeted characters and objects are located.
	 * */
	public void doAbility(AbilityName name, Position target) {
		battle.checkTurn(turnNumber);

		Ability ability = getAbility(name);
		if (ability == null) return;
		if (ability.info.effect.equals(pushEffect)) {
			mp -= ability.info.cost;
		} else {
			ap -= ability.info.cost;
		}
		Position p0 = character.position;

		Collection<Position> targets = ability.getTargets(
			ability.getAffectedArea(character.position, target, battle), battle);

		ability.applyEffect(character, target, battle);

		battle.controller.callOnAbility(p0, character.position, targets, ability.info);
	}

	/**
	 * Get all the positions that could be targeted by an item.
	 * */
	public Collection<Position> getItemRange(Item item) {
		AbilityInfo info = item.getAbility();

		return LineOfSight.getDiamond(character.position, info.range).stream()
			.filter(p -> canUseItem(item, p))
			.collect(Collectors.toList());
	}

	/**
	 * Determine if this character is able to use the specified item targeting
	 * the specified square.  In the case of items that are used on oneself, the
	 * target parameter will be set to the position of this character.
	 * */
	public boolean canUseItem(Item item, Position target) {
		if (item.getAbility().cost > ap) return false;
		return item.ability.canApplyEffect(character, target, battle);
	}

	/**
	 * Get the area of affect from using an item.  Some items such as grenades
	 * might have an area of effect
	 * */
	public Collection<Position> getItemAffectedArea(Item item, Position target) {
		return item.ability.getAffectedArea(character.position, target, battle);
	}

	/**
	 * Get the targets from using an item.  Essentially the same as getTargets
	 * but for items rather than character abilities.
	 * */
	public Collection<Position> getItemTargets(Item item, Position target) {
		return item.ability.getTargets(
			item.ability.getAffectedArea(
				character.position, target, battle), battle);
	}

	/**
	 * Use an item targeting the specified square.  In the case of items that are
	 * used on oneself, the target parameter will be set to the position of this
	 * character.
	 * */
	public void useItem(Item item, Position target) {
		battle.checkTurn(turnNumber);

		ap -= item.ability.info.cost;

		Position p0 = character.position;

		Collection<Position> targets = item.ability.getTargets(
			item.ability.getAffectedArea(
				character.position, target, battle), battle);

		item.ability.applyEffect(character, target, battle);

		battle.controller.callOnAbility(
			p0, character.position, targets, item.ability.info);
	}

	public CharacterName getName() {
		return character.name;
	}

	public Position getPos() {
		return character.position;
	}

	public int getLevel() {
		return character.getLevel();
	}

	public Points getHP() {
		return new Points(character.getMaxHP(), character.hp);
	}

	public Points getAP() {
		return new Points(maxAP, ap);
	}
	public Points getMP() {
		return new Points(maxMP, mp);
	}

	public Collection<Equipment> getVisibleEquipment() {
		return character.getVisibleEquipment();
	}

	/**
	 * Get a copy of essential information about a character
	 * */
	public CharacterInfo getCharacterInfo() {
		CharacterInfo info = character.getCharacterInfo(isOnManaZone());
		info.mp = getMP();
		info.ap = getAP();
		return info;
	}

	public boolean isOnManaZone() {
		return battle.terrain.isManaZone(character.position);
	}

	/**
	 * Determine if this character has enough action points to carry out another
	 * action on this turn
	 * */
	public boolean hasOptions(Collection<Item> items) {
		boolean canUseItem = items.stream()
			.anyMatch(i -> i.ability.info.cost <= ap);
		boolean canUseAbility = character.getAbilities(isOnManaZone()).stream()
			.anyMatch(a -> a.info.cost <= ap);
		return canUseItem || canUseAbility;
	}
}

