package inthezone.battle.data;

import java.util.Optional;

/**
 * A partially or fully autogenerated ability description.
 * */
public class AbilityDescription {
	private final AbilityInfo ability;
	private String description;

	public AbilityDescription(AbilityInfo ability) {
		this.ability = ability;
		this.description = generateDescription(ability);
	}

	@Override public String toString() { return description; }

	private static String generateDescription(AbilityInfo a) {
		StringBuilder s = new StringBuilder();
		s.append(a.name).append(" (").append(a.type.toString()).append(")");
		s.append(" -- ").append(a.ap).append(" AP");
		if (a.mp > 0) {
			s.append(", ").append(a.mp).append(" MP");
		}
		if (a.range.range > 1) {
			s.append(", Range ").append(a.range.range);
		}
		s.append("\n");

		if (a.banned) {
			s.append("\n");
			s.append("=== NOTICE ===");
			s.append("\"").append(a.name).append("\" is no longer permitted for tournament play.");
			s.append("Please remove \"").append(a.name).append("\" from all your characters.");
			s.append("\n");
			s.append("\n");
		}

		final String p1 = s.toString();
		s = new StringBuilder();
		generateTopLevelAbility(s, a);
		final String p2 = s.toString();

		return p1 + p2.substring(0, 1).toUpperCase() + p2.substring(1);
	}

	private static void generateTopLevelAbility(StringBuilder s, AbilityInfo a) {
		if (a.trap) {
			generateTrap(s, a);
		} else if (a.zone == AbilityZoneType.BOUND_ZONE) {
			generateBoundZone(s, a);
		} else {
			generateAbility(s, a);
		}

		Optional<AbilityInfo> next = a.subsequent;
		if (next.isPresent()) {
			s.append(" Next, ");
			if (a.range.range > 0 && next.get().range.range > 0) {
				s.append("from each of the previous targets, ");
			}
			generateTopLevelAbility(s, next.get());
		}
	}

	private static void generateBoundZone(StringBuilder s, AbilityInfo a) {
		final InstantEffectInfo obstacles;
		try {
			obstacles = new InstantEffectInfo("obstacles");
		} catch (Exception e) {
			throw new RuntimeException("obstacles type is invalid.  This cannot happen");
		}

		if (!a.instantBefore.equals(Optional.of(obstacles))) {
			s.append("ERROR: This ability attempts to make a bound zone, but it doesn't have obstacles as it's pre-effect");
		} else {
			s.append("create");
			if (a.range.nTargets == 1) {
				s.append(" a bound zone");
			} else {
				s.append(a.range.nTargets).append(" bound zones");
			}
			s.append(" with radius ").append(a.range.radius);
			if (a.range.piercing) s.append(" including the attack path");
			s.append(". The zone will ");
			generateAbility(s, a);
		}
	}

	private static void generateTrap(StringBuilder s, AbilityInfo a) {
		s.append("Place a trap which is activated when stepped on by ");
		if (a.range.targetMode.enemies && a.range.targetMode.allies && a.range.targetMode.self) {
			s.append("anyone");
		} else if (a.range.targetMode.enemies && a.range.targetMode.allies) {
			s.append("any other character (friend or foe)");
		} else if (a.range.targetMode.enemies) {
			s.append("enemies");
			if (a.range.targetMode.self) {
				s.append(" (or when you step on it)");
			}
		} else {
			s.append("allies");
			if (a.range.targetMode.self) {
				s.append(" (including yourself)");
			}
		}

		s.append(". When activated, the trap will ");
		generateAbility(s, a);
	}

	private static void generateAbility(StringBuilder s, AbilityInfo a) {
		final InstantEffectInfo obstacles;
		try {
			obstacles = new InstantEffectInfo("obstacles");
		} catch (Exception e) {
			throw new RuntimeException("obstacles type is invalid.  This cannot happen");
		}

		boolean isSecondary = false;
		if (a.instantBefore.isPresent()) {
			if (!(a.zone == AbilityZoneType.BOUND_ZONE && a.instantBefore.get().equals(obstacles))) {
				generateInstantEffect(s, a, a.instantBefore.get(), isSecondary);
				isSecondary = true;
			}
		}

		boolean noDamage = false;
		if (a.eff == 0) {
			noDamage = true;

		} else if (a.heal) {
			if (isSecondary) s.append(", then ");

			s.append("heal");
			generateTargetMode(s, a, isSecondary, false);
			s.append(" for ").append(formatDouble(a.eff, 2)).append("x heal");
			isSecondary = true;

		} else {
			if (isSecondary) s.append(", then ");

			s.append("attack");
			generateTargetMode(s, a, isSecondary, false);
			s.append(" for ").append(formatDouble(a.eff, 2)).append("x damage");
			isSecondary = true;
		}

		if (a.statusEffect.isPresent()) {
			if (noDamage) {
				if (isSecondary) s.append(", then ");

				if (a.statusEffect.get().kind == StatusEffectKind.BUFF) {
					s.append("give ");
				} else {
					s.append("inflict ");
				}

				s.append(a.statusEffect.get().toNiceString());

				if (a.chance < 1f) {
					s.append(" with a ").append(formatPercent(a.chance)).append(" chance of success");
				}

			} else if (a.chance < 1f) {
				s.append(" with a ").append(formatPercent(a.chance)).append(" chance to");
				if (a.statusEffect.get().kind == StatusEffectKind.BUFF) {
					s.append(" give ");
				} else {
					s.append(" inflict ");
				}
				s.append(a.statusEffect.get().toNiceString());

			} else {
				if (a.statusEffect.get().kind == StatusEffectKind.BUFF) {
					s.append(", giving ");
				} else {
					s.append(", inflicting ");
				}
				s.append(a.statusEffect.get().toNiceString());
			}

			isSecondary = true;
		}


		if (a.instantAfter.isPresent()) {
			if (isSecondary) s.append(", then ");
			generateInstantEffect(s, a, a.instantAfter.get(), isSecondary);
		}

		s.append(".");

		if (!a.range.los) {
			s.append(" Does not require line of sight to the target(s).");
		}

		if (a.zone == AbilityZoneType.ZONE) {
			s.append(" The targeted area becomes a zone lasting 4 turns.");
		}

		if (a.recursion == 1) {
			s.append(" Rebounds once.");
		} else if (a.recursion == 2) {
			s.append(" Rebounds twice.");
		} else if (a.recursion > 2) {
			s.append(" Rebounds ").append(a.recursion).append(" times.");
		}
	}

	private static String formatDouble(double d, int decimalPlaces) {
		String r = "" + Math.round(d * (Math.pow(10, decimalPlaces)));
		while (r.length() < (decimalPlaces + 1)) r = "0" + r;
		while (r.endsWith("0")) r = r.substring(0, r.length() - 1);
		r = r.substring(0, 1) + "." + r.substring(1);
		if (r.endsWith(".")) return r.substring(0, r.length() - 1); else return r;
	}

	private static String formatPercent(double d) {
		return "" + Math.round(d * 100) + "%";
	}

	private static void generateInstantEffect(
		StringBuilder s, AbilityInfo a, InstantEffectInfo e, boolean isSecondaryEffect
	) {
		switch (e.type) {
			case CLEANSE:
				s.append("cleanse");
				generateTargetMode(s, a, isSecondaryEffect, false);
				break;
			case DEFUSE:
				s.append("defuse");
				generateTargetMode(s, a, isSecondaryEffect, true);
				break;
			case PURGE:
				s.append("purge");
				generateTargetMode(s, a, isSecondaryEffect, true);
				break;
			case PUSH:
				s.append("push");
				generateTargetMode(s, a, isSecondaryEffect, false);
				if (e.param == 1) {
					s.append(" one square");
				} else {
					s.append(" ").append(e.param).append(" squares");
				}
				break;
			case PULL:
				s.append("pull");
				generateTargetMode(s, a, isSecondaryEffect, false);
				if (e.param == 1) {
					s.append(" one square");
				} else {
					s.append(" ").append(e.param).append(" squares");
				}
				break;
			case SCAN:
				s.append("scan");
				break;
			case TELEPORT:
				s.append("Teleport");
				generateTargetMode(s, a, isSecondaryEffect, false);
				if (e.param == 1) {
					s.append(" to an adjacent square");
				} else {
					s.append(" up to ").append(e.param).append(" squares");
				}
				break;
			case OBSTACLES:
				s.append("place");
				if (a.range.nTargets == 1) {
					s.append(" one obstacle which persists until destroyed");
				} else {
					s.append(a.range.nTargets).append(" obstacles which persist until destroyed");
				}
				break;
			case MOVE:
				s.append("move");
				generateTargetMode(s, a, isSecondaryEffect, false);
				if (e.param == 1) {
					s.append(" to an adjacent square");
				} else {
					s.append(" up to ").append(e.param).append(" squares");
				}
				break;
			case REVIVE:
				s.append("revive");
				generateTargetMode(s, a, isSecondaryEffect, false);
				break;
		}
	}

	private static void generateSecondaryTargetMode(
		StringBuilder s, AbilityInfo a, boolean noTargetCharacters
	) {
		boolean trapZone = a.trap || a.zone == AbilityZoneType.BOUND_ZONE;

		if (noTargetCharacters) {
			s.append(" all targeted squares");
		} else if (a.range.targetMode.enemies && a.range.targetMode.allies) {
			s.append(" all targeted characters");
		} else if (a.range.targetMode.enemies) {
			s.append(" all targeted enemies");
		} else if (a.range.targetMode.allies) {
			s.append(" all targeted allies");
		} if (a.range.targetMode.self) {
			s.append(" yourself");
			if (!trapZone) {
				s.append(" (only if you targeted yourself)");
			}
		}

		if (a.range.targetMode.self && !noTargetCharacters) {
			if (trapZone) {
				s.append(" (including yourself)");
			} else {
				s.append(" (including yourself if you targeted yourself)");
			}
		}
	}

	private static void generateTargetMode(
		StringBuilder s, AbilityInfo a, boolean isSecondary, boolean noTargetCharacters
	) {
		if (isSecondary) {
			generateSecondaryTargetMode(s, a, noTargetCharacters);
			return;
		}

		boolean trapZone = a.trap || a.zone == AbilityZoneType.BOUND_ZONE;

		if (a.range.range == 0 || trapZone) {
			if (a.range.radius > 0 && a.zone != AbilityZoneType.BOUND_ZONE) {
				if (a.trap) s.append(" the target and");
				
				s.append(" all");
				if (a.range.radius == 1) s.append(" adjacent");

				final String cont;
				if (noTargetCharacters) {
					s.append(" squares");
					cont = "squares";
				} else if (a.range.targetMode.enemies && a.range.targetMode.allies) {
					s.append(" characters");
					cont = "characters";
				} else if (a.range.targetMode.enemies) {
					s.append(" enemies");
					cont = "enemies";
				} else {
					s.append(" allies");
					cont = "allies";
				}

				if (a.range.targetMode.self) {
					s.append(" (including yourself)");
				}

				if (a.range.radius > 1 && !trapZone) {
					s.append(" within range ").append(a.range.radius);
				}

				if (a.range.piercing && !trapZone) {
					s.append(" including all ").append(cont).append(" on the attack path");
				}

			} else if (
				a.range.targetMode.self && !a.range.targetMode.enemies && !a.range.targetMode.allies)
			{
				if (noTargetCharacters) s.append(" your square"); else s.append(" yourself");
			} else {
				if (noTargetCharacters) {
					s.append(" your square");
				} else if (a.zone == AbilityZoneType.BOUND_ZONE) {
					if (a.range.targetMode.enemies && a.range.targetMode.allies) {
						s.append(" any character");
					} else if (a.range.targetMode.enemies) {
						s.append(" any enemy");
					} else {
						s.append(" any ally");
					}
					if (a.range.targetMode.self) {
						s.append(" (including yourself)");
					}
				} else if (a.trap) {
					s.append(" the target");
				} else {
					s.append(a.range.targetMode.toString())
						.append(" (but this is range 0 so enemies and allies cannot be affected)");
				}
			}
		} else if (a.range.radius == 0) {
			if (a.range.nTargets == 0) {
				s.append(" NO");
			} else if (a.range.nTargets == 1) {
				s.append(" one");
			} else s.append(" ").append(a.range.nTargets);

			if (a.range.range == 1) s.append(" adjacent");

			if (noTargetCharacters) {
				s.append(a.range.nTargets == 1? " square" : " squares");
			} else if (a.range.targetMode.enemies && a.range.targetMode.allies) {
				s.append(a.range.nTargets == 1? " character" : " characters");
			} else if (a.range.targetMode.enemies) {
				s.append(a.range.nTargets == 1? " enemy" : " enemies");
			} else {
				s.append(a.range.nTargets == 1? " ally" : " allies");
			}

			if (a.range.targetMode.self && !noTargetCharacters) {
				s.append(" (you can also target yourself)");
			}

		} else {
			s.append(" all");

			if (noTargetCharacters) {
				s.append(" squares");
			} else if (a.range.targetMode.enemies && a.range.targetMode.allies) {
				s.append(" characters");
			} else if (a.range.targetMode.enemies) {
				s.append(" enemies");
			} else {
				s.append(" allies");
			}

			s.append(" within");

			if (a.range.radius == 1) {
				s.append(" one square");
			} else {
				s.append(" ").append(a.range.radius).append(" squares");
			}

			if (a.range.nTargets == 1) {
				s.append(" of the targeted square");
			} else {
				s.append(" of any of the ").append(a.range.nTargets).append(" targeted squares");
			}
		}
	}
}

